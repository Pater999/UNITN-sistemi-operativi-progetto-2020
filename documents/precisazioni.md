#### Elenco di tutte le precisazioni ricevute per mail riguardanti il progetto

- I led rappresentano un "feedback" di interruttori/pulsanti: si attivano quando è attivato il comando corrispondente a prescindere dal risultato dell'azione (con successo o meno)

- Un "interruttore" ha una posizione OFF ed una ON da selezionare alternativamente "a mano", mentre un "pulsante" sta sempre in posizione OFF a riposo e quando lo si comanda passa in posizione ON e poi torna "automaticamente" in posizione OFF. Sarebbe utile forzare un tempo minimo artificioso di ritorno a tale posizione (ad esempio dopo almeno mezzo secondo o anche un secondo).

- I processi "S" fanno da intermediari tra tutti gli altri processi e quindi anche tra "T" ed "L" (processi o elementi hardware)

- Il processo "Q" deve interrogare "direttamente" i vari "P": questo significa che non può conoscere la posizione nella lista di uno di essi o l'identificativo chiedendo ad altri. L'unica cosa che può fare è richiedere un riferimento (che cosa dipende dal metodo di comunicazione che si riesce a realizzare) al gestore e poi usarlo per interrogare direttamente il singolo P. In linea di massima Q può solo chiedere al gestore "dammi un riferimento al processo n-esimo" o qualcosa del genere.

- I processi "P" sono uno figlio dell'altro in cascata.

- Un pulsante comanda un'azione: a prescindere dal fatto che si utilizzi solo la rilevazione di un dispositivo fisico (con o senza ritardi "artificiosi" aggiuntivi) o che si usi un'emulazione l'importante è che vi sia coerenza.

  - In linea di massima potrebbero esserci due tipologie di soluzione: una che prevede anche comandi "a vuoto" (se ad esempio si preme troppe volte un pulsante mentre l'azione è ancora in corso) e una che gestisce delle "code". Potrebbero essere valide entrambe. Fondamentale è che non vi siano errori o situazioni non gestite e che si abbia un quadro della situazione (ad esempio segnalando che c'è un'azione in corso nel primo caso e/o mostrando/gestendo la coda nel secondo, ma sono solo esempi). Questo potrebbe valere sia per i pulsanti che per gli interruttori.

  - In particolare per la variante "U" usare un ritardo artificioso nel ritorno alla posizione di riposo di un pulsante può essere utile (ci sono anche altre strategie) tenendo conto che un pulsante fisico essendo comandato "a mano" ha un tempo di passaggio OFF->ON->OFF e che normalmente possono essere addirittura premuti (OFF->ON), mantenuti in pressione (anche per molto tempo, ON<->ON) e poi rilasciati (ON->OFF).

- I led devono essere accesi se il comando corrispondente (che sia un pulsante, quindi fintantochè si tiene premuto, o un interruttore, quindi quando è nella posizione corrispondente) è a ON, spenti se è a OFF.
- Nella variante "U" le interazioni con essi - come tutte le altre di qualunque genere - devono avvenire solo ed esclusivamente dal terminale (quindi normalmente tramite la tastiera premendo un tasto o inserendo dei comandi seguiti da INVIO ad esempio) e MAI con interazioni "grafiche" (ad esempio con il mouse).
- "mantere premuto un pulsante" (nel caso di comandi come pulsanti): quando si agisce su un pulsante di quelli che si usano nelle scale di un palazzo, solitamente si accende la luce. A tal punto noi possiamo mantenere premuto il pulsante a piacere (non andrebbe fatto in pratica, ma è solo un esempio) e poi rilasciarlo. Solo successivamente possiamo riutilizzarlo (per riaccendere la luce se è temporizzata e/o per spegnerla se consentito). Il "mantere premuto" è un evento che in effetti c'è sempre, ma a volte per un lasso di tempo ridottissimo. Con oggetti fisici (variante "R") è ovviamente possibile farlo, con oggetti virtuali (variante "U") è opportuno simulare tale possibilità.
- Informazioni di ritorno e accensione/spegnimento: se i LED sono emulati (variante "U") ha senso ricreare la situazione di oggetti reali... da tenere conto che nel testo si dice tra le altre cose: "led: hanno uno stato acceso/spento verificabile".
- Nel testo si dice che "Deve essere realizzato poi un eseguibile a parte (processo “Q”) che - interfacciandosi in qualche modo con l'altro principale [M][...]", quindi si deve creare un eseguibile SEPARATO (posso aprire due finestre separate di terminale e lanciarli uno alla volta). La modalità di interazione deve avvenire sfruttando una delle modalità elencate dove si dice "le comunicazioni tra processi [...]" e fa parte delle scelte implementative.
- Può essere utile/necessario aprire più terminali (intendendo "finestre con shell bash") così da lanciare più eseguibili per mostrare il progetto in esecuzione (ad esempio per lanciare M e Q e magari anche altri ad esempio per "gestire" - interagire e/o dare feedback - i comandi e/o i led), ma non può e non deve essere l'applicazione a farlo (non dal codice "C" insomma): questa azione può essere eseguita o semplicemente dall'utente "a mano" (si aprono due finestre e si procede) o eventualmente tramite uno script bash di appoggio (solo per comodità).
- In ogni caso NON si devono sfruttare strategie per far sì che aprendo due terminali in qualche modo particolare i processi abbiano accesso a informazioni/canali dedicati: deve sempre essere possibile aprire tali finestre a mano separatamente e in momenti successivi e tutto deve funzionare.
